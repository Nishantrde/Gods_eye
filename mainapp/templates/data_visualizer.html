<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Interactive Data Visualizer</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    /* Import a Google Font (optional enhancement) */
    @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600&display=swap');

    /* Global styling */
    body {
      margin: 0;
      font-family: 'Nunito', sans-serif;
      display: flex;
      background: linear-gradient(135deg, #f4f4f9, #e2e6ea);
      color: #333;
      overflow-x: hidden;
      animation: fadeIn 1s ease-out forwards;
      opacity: 0;
    }
    
    @keyframes fadeIn {
      to { opacity: 1; }
    }

    /* Sidebar styling */
    .sidebar {
      width: 300px;
      background: #2c3e50;
      color: #fff;
      padding: 10px;
      box-shadow: 2px 0 10px rgba(0, 0, 0, 0.2);
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      overflow-y: auto;
      z-index: 1;
      transform: translateX(-100%);
      animation: slideIn 0.8s ease-out forwards;
    }
    
    @keyframes slideIn {
      to { transform: translateX(0); }
    }

    .sidebar h2,
    .sidebar h3 {
      margin-top: 0;
      font-weight: 600;
    }
    
    .sidebar label {
      display: block;
      margin-top: 15px;
      font-size: 14px;
    }
    
    .sidebar select,
    .sidebar button {
      width: 100%;
      padding: 8px;
      margin-top: 5px;
      border-radius: 5px;
      border: none;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    
    .sidebar button {
      background: #4A90E2;
      color: #fff;
      cursor: pointer;
    }
    
    .sidebar button:hover {
      background: #357ABD;
    }
    
    .sidebar hr {
      margin: 20px 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
    }

    /* Container styling */
    .container {
      flex-grow: 1;
      padding: 20px 40px;
      text-align: center;
      animation: fadeInUp 1s ease-out forwards;
      opacity: 0;
      /* Adjust left margin so content is not hidden behind the fixed sidebar */
      margin-left: 290px;
    }
    
    @keyframes fadeInUp {
      from {
        transform: translateY(20px);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    h1 {
      margin-bottom: 30px;
      color: #34495e;
      font-size: 32px;
      animation: popIn 0.6s ease-out;
    }
    
    @keyframes popIn {
      from { transform: scale(0.8); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    /* Chart wrapper layout */
    .chart-wrapper {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    /* Flex container for the first row of charts */
    .chart-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
    }
    
    /* Adjust SVG styling */
    svg {
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
      transition: transform 0.3s ease;
    }
    
    svg:hover {
      transform: scale(1.02);
    }

    /* Tooltip styling */
    #tooltip {
      position: absolute;
      z-index: 9999;
      background: rgba(0, 0, 0, 0.75);
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
  </style>
</head>
<body>
  <div id="tooltip"></div>  
  <div class="sidebar">
    <h2>Chart Options</h2>
    <h3>Bar Chart</h3>
    <label for="bar-x">X-Axis:</label>
    <select id="bar-x">
      <option value="sector">Sector</option>
      <option value="region">Region</option>
      <option value="country">Country</option>
      <option value="topic">Topic</option>
    </select>
    <label for="bar-y">Y-Axis:</label>
    <select id="bar-y">
      <option value="intensity">Intensity</option>
      <option value="relevance">Relevance</option>
      <option value="likelihood">Likelihood</option>
    </select>
    <button id="sort-button">Sort Bars</button>
    
    <hr>
    <h3>Pie Chart</h3>
    <label for="pie-grouping">Grouping:</label>
    <select id="pie-grouping">
      <option value="sector">Sector</option>
      <option value="region">Region</option>
      <option value="pestle">Pestle</option>
      <option value="topic">Topic</option>
      <option value="country">Country</option>
    </select>
    <label for="pie-based_on">Based On:</label>
    <select id="pie-based_on">
      <option value="intensity">Intensity</option>
      <option value="relevance">Relevance</option>
      <option value="likelihood">Likelihood</option>
    </select>
    
    <hr>
    <h3>Line Chart</h3>
    <label for="line-y">Y-Axis:</label>
    <select id="line-y">
      <option value="intensity">Intensity</option>
      <option value="relevance">Relevance</option>
      <option value="likelihood">Likelihood</option>
      <option value="pop">Population</option>
    </select>
    <label for="line-date">Date Field:</label>
    <select id="line-date">
      <option value="published">Published</option>
      <option value="added">Added</option>
    </select>
    
    <hr>
    <h3>Geographical Map</h3>
    <label for="map-mode">Map Mode:</label>
    <select id="map-mode">
      <option value="impact">Impact by Country</option>
      <option value="topics">Topic Frequency by Country</option>
    </select>
  </div>
  <div class="container">
    <h1>Interactive Data Visualizer</h1>
    <div class="chart-wrapper">
      <!-- Row for Bar and Pie charts -->
      <div class="chart-row">
        <svg id="bar-chart" width="630" height="400"></svg>
        <svg id="pie-chart" width="630" height="400"></svg>
      </div>
      <!-- Line chart -->
      <svg id="line-chart" width="1180" height="300"></svg>
      <!-- Geographical Map -->
      <svg id="map-chart" width="1180" height="500"></svg>
    </div>
  </div>

  <script>
    // Replace this with your actual data injection method (e.g. server-side templating)
    let data = {{ data|safe }};
    // console.log(data)
    
    // Global flag to toggle sorting state for the bar chart
    let isSorted = false;
    
    // Helper function to map GeoJSON country names to the names used in your data.
    // Extend this dictionary with any additional mappings you require.
    function normalizeCountryName(geoName) {
      const mapping = {
        "USA": "United States of America",
        "United States": "United States of America",
        "England": "United Kingdom",
        "U.K.": "United Kingdom",
        "Great Britain": "United Kingdom",
        "UAE": "United Arab Emirates"
        // Add additional mappings as needed.
      };
      return mapping[geoName] || geoName;
    }
    
    // BAR CHART UPDATE FUNCTION
    function updateBarChart() {
      const xAttr = document.getElementById("bar-x").value;
      const yAttr = document.getElementById("bar-y").value;
      const filteredData = data.filter(d => d[xAttr] && d[yAttr]);
      
      // Group data by the selected x-axis attribute and calculate the average for y-axis attribute
      let groupedData = Array.from(
        d3.rollup(filteredData, v => d3.mean(v, d => +d[yAttr]), d => d[xAttr]),
        ([key, value]) => ({ key, value })
      );
      
      // If sorting is toggled on, sort the grouped data (largest values first)
      if (isSorted) {
        groupedData.sort((a, b) => b.value - a.value);
      }
      
      const svg = d3.select("#bar-chart");
      const margin = { top: 20, right: 20, bottom: 50, left: 60 },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom;
      
      // Use a group element for chart content (create it if it doesn't exist)
      let g = svg.select("g.chart-group");
      if (g.empty()) {
        g = svg.append("g")
               .attr("class", "chart-group")
               .attr("transform", `translate(${margin.left},${margin.top})`);
      }
      
      // Update scales
      const xScale = d3.scaleBand()
                       .domain(groupedData.map(d => d.key))
                       .range([0, width])
                       .padding(0.2);
      const yScale = d3.scaleLinear()
                       .domain([0, d3.max(groupedData, d => d.value)]).nice()
                       .range([height, 0]);
      
      // Update axes with transitions
      let xAxis = g.select("g.x-axis");
      if (xAxis.empty()) {
        xAxis = g.append("g")
                 .attr("class", "x-axis")
                 .attr("transform", `translate(0, ${height})`);
      }
      xAxis.transition().duration(750)
           .call(d3.axisBottom(xScale))
           .selectAll("text")
             .attr("transform", "rotate(-20)")
             .attr("text-anchor", "end")
             .style("fill", "#555");
      
      let yAxis = g.select("g.y-axis");
      if (yAxis.empty()) {
        yAxis = g.append("g")
                 .attr("class", "y-axis");
      }
      yAxis.transition().duration(750)
           .call(d3.axisLeft(yScale))
           .selectAll("text")
             .style("fill", "#555");
      
      // Define the gradient (if not already defined)
      let defs = svg.select("defs");
      if (defs.empty()) {
        defs = svg.append("defs");
        const gradient = defs.append("linearGradient")
                             .attr("id", "gradient")
                             .attr("x1", "0%")
                             .attr("y1", "0%")
                             .attr("x2", "0%")
                             .attr("y2", "100%");
        gradient.append("stop")
                .attr("offset", "0%")
                .attr("stop-color", "#4A90E2");
        gradient.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", "#357ABD");
      }
      
      // Data join for bars using a key function (by category)
      const bars = g.selectAll(".bar")
                    .data(groupedData, d => d.key);
      
      // Exit any bars no longer needed
      bars.exit().remove();
      
      // Update existing bars with a transition to new positions and heights
      bars.transition().duration(750)
          .attr("x", d => xScale(d.key))
          .attr("y", d => yScale(d.value))
          .attr("width", xScale.bandwidth())
          .attr("height", d => height - yScale(d.value));
      
      // Enter new bars from a collapsed state and animate their appearance
      bars.enter().append("rect")
          .attr("class", "bar")
          .attr("x", d => xScale(d.key))
          .attr("y", height)
          .attr("width", xScale.bandwidth())
          .attr("height", 0)
          .attr("fill", "url(#gradient)")
          .on("mouseover", (event, d) => {
            d3.select("#tooltip")
              .style("opacity", 1)
              .html(`<strong>${d.key}:</strong> ${d.value.toFixed(2)}`)
              .style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 28}px`);
            d3.select(event.currentTarget)
              .transition().duration(200)
              .attr("fill", "#2C80B4");
          })
          .on("mouseout", (event, d) => {
            d3.select("#tooltip").style("opacity", 0);
            d3.select(event.currentTarget)
              .transition().duration(200)
              .attr("fill", "url(#gradient)");
          })
          .transition()
            .duration(1000)
            .ease(d3.easeBounceOut)
            .attr("y", d => yScale(d.value))
            .attr("height", d => height - yScale(d.value));
    }
    
    // PIE CHART UPDATE FUNCTION
    function updatePieChart() {
      const groupAttr = document.getElementById("pie-grouping").value;
      const basedOnAttr = document.getElementById("pie-based_on").value;
      
      // Filter the data to ensure both attributes exist
      const filteredData = data.filter(d => d[groupAttr] && d[basedOnAttr]);
      
      // Group the data by the selected grouping attribute and aggregate (using mean) the based_on attribute.
      let rawData = Array.from(
        d3.rollup(
          filteredData, 
          v => d3.mean(v, d => parseFloat(d[basedOnAttr]) || 0),
          d => d[groupAttr]
        ),
        ([key, value]) => ({ key, count: value })
      );
    
      // Optionally group smaller slices into "Others"
      const totalValue = d3.sum(rawData, d => d.count);
      const threshold = totalValue * 0.05;
      let groupedData = [];
      let othersTotal = 0;
      
      rawData.forEach(d => {
        if (d.count < threshold) {
          othersTotal += d.count;
        } else {
          groupedData.push(d);
        }
      });
      
      if (othersTotal > 0 && othersTotal < totalValue * 0.5) {
        groupedData.push({ key: "Others", count: othersTotal });
      } else if (othersTotal >= totalValue * 0.5) {
        groupedData = rawData;
      }
      
      // Clear previous SVG content for the pie chart
      const svg = d3.select("#pie-chart");
      svg.selectAll("*").remove();
      const width = +svg.attr("width"),
            height = +svg.attr("height"),
            radius = Math.min(width, height) / 2 - 50;
      const g = svg.append("g")
                   .attr("transform", `translate(${width / 2}, ${height / 2})`);
      
      // Create the pie layout
      const pie = d3.pie().sort(null).value(d => d.count);
      const arc = d3.arc().innerRadius(0).outerRadius(radius);
      const arcHover = d3.arc().innerRadius(0).outerRadius(radius + 10);
      const labelArc = d3.arc().innerRadius(radius + 20).outerRadius(radius + 20);
      const color = d3.scaleOrdinal(d3.schemeCategory10);
      
      const arcs = g.selectAll(".arc")
        .data(pie(groupedData))
        .enter().append("g")
        .attr("class", "arc");
      
      arcs.append("path")
          .attr("d", d => {
            const start = { startAngle: d.startAngle, endAngle: d.startAngle };
            return arc(start);
          })
          .attr("fill", (d, i) => color(i))
          .transition()
            .duration(1000)
            .attrTween("d", function(d) {
              const interpolate = d3.interpolate(
                { startAngle: d.startAngle, endAngle: d.startAngle },
                d
              );
              return function(t) {
                return arc(interpolate(t));
              };
            })
          .each(function(d) { this._current = d; });
      
      arcs.append("text")
          .attr("transform", d => `translate(${labelArc.centroid(d)})`)
          .attr("text-anchor", "middle")
          .attr("fill", "#333")
          .attr("opacity", 0)
          .text(d => d.data.key)
          .transition()
            .delay(1000)
            .duration(500)
            .attr("opacity", 1);
      
      arcs.on("mouseover", function(event, d) {
            d3.select("#tooltip")
              .style("opacity", 1)
              .html(`<strong>${d.data.key}:</strong> ${d.data.count}`)
              .style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 28}px`);
            d3.select(this).select("path")
              .transition().duration(200)
              .attr("d", arcHover);
          })
          .on("mouseout", function(event, d) {
            d3.select("#tooltip").style("opacity", 0);
            d3.select(this).select("path")
              .transition().duration(200)
              .attr("d", arc);
          });
    }
    
    // LINE CHART UPDATE FUNCTION WITH ZOOM
    function updateLineChart() {
      // Get the selected options for y-axis and date field
      const yAttr = document.getElementById("line-y").value;
      const dateField = document.getElementById("line-date").value;
      
      // Filter out data entries missing either the date or y-axis value.
      const filteredData = data.filter(d => d[dateField] && d[yAttr]);
      
      // Parse the date strings. Adjust the parser if your dates are in a different format.
      filteredData.forEach(d => {
        d.parsedDate = new Date(d[dateField]);
        d[yAttr] = +d[yAttr];
      });
      
      // Sort data by the parsed date.
      filteredData.sort((a, b) => a.parsedDate - b.parsedDate);
      
      const svg = d3.select("#line-chart");
      svg.selectAll("*").remove(); // Clear previous contents
      
      const margin = { top: 20, right: 20, bottom: 50, left: 60 },
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom;
      
      const g = svg.append("g")
                   .attr("transform", `translate(${margin.left},${margin.top})`);
      
      // Create scales: time scale for the x-axis and linear scale for y-axis.
      const xScale = d3.scaleTime()
                       .domain(d3.extent(filteredData, d => d.parsedDate))
                       .range([0, width]);
      
      const yScale = d3.scaleLinear()
                       .domain([0, d3.max(filteredData, d => d[yAttr])]).nice()
                       .range([height, 0]);
      
      // Define the line generator
      const line = d3.line()
                     .x(d => xScale(d.parsedDate))
                     .y(d => yScale(d[yAttr]))
                     .curve(d3.curveMonotoneX);
      
      // Add x-axis
      const xAxis = g.append("g")
       .attr("class", "x-axis")
       .attr("transform", `translate(0, ${height})`)
       .call(d3.axisBottom(xScale))
       .selectAll("text")
         .attr("transform", "rotate(-20)")
         .attr("text-anchor", "end")
         .style("fill", "#555");
      
      // Add y-axis
      g.append("g")
       .attr("class", "y-axis")
       .call(d3.axisLeft(yScale))
       .selectAll("text")
         .style("fill", "#555");
      
      // Append the line path with a class for zoom updates
      const path = g.append("path")
                    .datum(filteredData)
                    .attr("class", "line")
                    .attr("fill", "none")
                    .attr("stroke", "#4A90E2")
                    .attr("stroke-width", 2)
                    .attr("d", line);
      
      // Animate the line drawing using stroke-dasharray
      const totalLength = path.node().getTotalLength();
      path
        .attr("stroke-dasharray", `${totalLength} ${totalLength}`)
        .attr("stroke-dashoffset", totalLength)
        .transition()
          .duration(1500)
          .ease(d3.easeLinear)
          .attr("stroke-dashoffset", 0);
      
      // Append circles for each data point with hover tooltips
      g.selectAll(".dot")
       .data(filteredData)
       .enter().append("circle")
         .attr("class", "dot")
         .attr("cx", d => xScale(d.parsedDate))
         .attr("cy", d => yScale(d[yAttr]))
         .attr("r", 4)
         .attr("fill", "#357ABD")
         .on("mouseover", (event, d) => {
            d3.select("#tooltip")
              .style("opacity", 1)
              .html(`<strong>Date:</strong> ${d[dateField]}<br/><strong>${yAttr}:</strong> ${d[yAttr]}`)
              .style("left", `${event.pageX + 10}px`)
              .style("top", `${event.pageY - 28}px`);
         })
         .on("mouseout", (event, d) => {
            d3.select("#tooltip").style("opacity", 0);
         });
      
      // Add a transparent rectangle on top of the chart to capture zoom events
      const zoom = d3.zoom()
        .scaleExtent([1, 10])
        .translateExtent([[0, 0], [width, height]])
        .extent([[0, 0], [width, height]])
        .on("zoom", zoomed);
      
      svg.append("rect")
         .attr("class", "zoom")
         .attr("width", width)
         .attr("height", height)
         .attr("transform", `translate(${margin.left},${margin.top})`)
         .style("fill", "none")
         .style("pointer-events", "all")
         .call(zoom);
      
      function zoomed(event) {
        const newXScale = event.transform.rescaleX(xScale);
        // Update x-axis with new scale
        g.select(".x-axis").call(d3.axisBottom(newXScale)
          .tickFormat(d3.timeFormat("%Y-%m-%d")));
        // Update the line path with the new x-scale
        g.selectAll("path.line")
          .attr("d", line.x(d => newXScale(d.parsedDate)));
        // Update the position of the circles
        g.selectAll("circle.dot")
          .attr("cx", d => newXScale(d.parsedDate));
      }
    }
    
    // GEOGRAPHICAL MAP UPDATE FUNCTION WITH ZOOM FEATURE
    function updateMapChart() {
      const mapMode = document.getElementById("map-mode").value;
      
      // Aggregate data by country.
      // For "impact" mode, use the "impact" field (or fallback to "intensity").
      // For "topics" mode, count topic frequency and pick the most common topic.
      let countryData = Array.from(
        d3.rollup(
          data.filter(d => d.country),
          v => {
            if (mapMode === "impact") {
              return d3.mean(v, d => +d.impact || +d.intensity);
            } else if (mapMode === "topics") {
              const topicFreq = {};
              v.forEach(d => {
                if (d.topic) {
                  topicFreq[d.topic] = (topicFreq[d.topic] || 0) + 1;
                }
              });
              // Get the topic with the highest frequency
              const topTopic = Object.entries(topicFreq).reduce((a, b) => a[1] > b[1] ? a : b, ["N/A", 0]);
              return { topic: topTopic[0], count: topTopic[1] };
            }
          },
          d => d.country
        ),
        ([country, value]) => ({ country, value })
      );
      
      // Load world GeoJSON (cache it if needed)
      d3.json("https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson").then(worldData => {
        const svg = d3.select("#map-chart");
        svg.selectAll("*").remove();
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        // Create a group to hold the map features and attach zoom behavior to it.
        const gMap = svg.append("g");

        const projection = d3.geoNaturalEarth1()
                             .scale(width / 1.3 / Math.PI)
                             .translate([width / 2, height / 2]);
        const path = d3.geoPath().projection(projection);

        // Create a lookup for country data.
        // Note: the keys in our data are the dataset names (e.g., "United States of America")
        // so we normalize the GeoJSON country names before the lookup.
        const dataMap = new Map();
        countryData.forEach(d => {
           dataMap.set(d.country, d.value);
        });

        // Define color scales based on mode.
        let color;
        if (mapMode === "impact") {
          color = d3.scaleSequential(d3.interpolateOrRd)
                    .domain(d3.extent(countryData, d => d.value));
        } else {
          // For topics, assign each topic a color from a categorical palette.
          const topics = Array.from(new Set(countryData.map(d => d.value.topic)));
          color = d3.scaleOrdinal()
                    .domain(topics)
                    .range(d3.schemeCategory10);
        }

        // Draw countries in the gMap group.
        gMap.selectAll("path")
           .data(worldData.features)
           .enter()
           .append("path")
             .attr("d", path)
             .attr("fill", d => {
                // Normalize the GeoJSON country name before looking it up.
                const normName = normalizeCountryName(d.properties.name);
                const datum = dataMap.get(normName);
                if (datum) {
                  if (mapMode === "impact") {
                    return color(datum);
                  } else {
                    return color(datum.topic);
                  }
                }
                return "#ccc";
             })
             .attr("stroke", "#fff")
             .attr("stroke-width", 0.5)
             .on("mouseover", function(event, d) {
                const normName = normalizeCountryName(d.properties.name);
                const datum = dataMap.get(normName);
                let tooltipContent;
                if (datum) {
                  if (mapMode === "impact") {
                    tooltipContent = `<strong>${normName}</strong><br>Average Impact: ${datum.toFixed(2)}`;
                  } else {
                    tooltipContent = `<strong>${normName}</strong><br>Top Topic: ${datum.topic} (${datum.count})`;
                  }
                } else {
                  tooltipContent = `<strong>${normName}</strong><br>No data`;
                }
                d3.select("#tooltip")
                  .style("opacity", 1)
                  .html(tooltipContent)
                  .style("left", `${event.pageX + 10}px`)
                  .style("top", `${event.pageY - 28}px`);
             })
             .on("mouseout", function() {
                d3.select("#tooltip").style("opacity", 0);
             });
        
        // Add zoom behavior to the map.
        const zoom = d3.zoom()
          .scaleExtent([1, 8])
          .on("zoom", (event) => {
            gMap.attr("transform", event.transform);
          });
        svg.call(zoom);
      });
    }
    
    // Event listeners for dropdown changes in the bar chart.
    document.getElementById("bar-x").addEventListener("change", updateBarChart);
    document.getElementById("bar-y").addEventListener("change", updateBarChart);
    document.getElementById("sort-button").addEventListener("click", function() {
      isSorted = !isSorted;
      this.textContent = isSorted ? "Reset Sorting" : "Sort Bars";
      updateBarChart();
    });
    
    // Event listeners for dropdown changes in the pie chart.
    document.getElementById("pie-grouping").addEventListener("change", updatePieChart);
    document.getElementById("pie-based_on").addEventListener("change", updatePieChart);
    
    // Event listeners for dropdown changes in the line chart.
    document.getElementById("line-y").addEventListener("change", updateLineChart);
    document.getElementById("line-date").addEventListener("change", updateLineChart);
    
    // Event listener for the geographical map dropdown.
    document.getElementById("map-mode").addEventListener("change", updateMapChart);
    
    // Initial render for all charts.
    updateBarChart();
    updatePieChart();
    updateLineChart();
    updateMapChart();
  </script>
</body>
</html>
